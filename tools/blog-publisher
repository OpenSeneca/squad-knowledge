#!/usr/bin/env python3
"""
Substack/Obsidian Markdown Formatter

Takes a blog draft output and formats it for publishing:
- Adds YAML frontmatter (title, date, tags, category, excerpt)
- Cleans up markdown formatting
- Strips internal metadata (agent name, domain number)
- Outputs Substack-ready or Obsidian-ready markdown

Usage:
    blog-publisher --target substack input.md > output.md
    blog-publisher --target obsidian input.md > output.md
    blog-publisher --input input.md --target substack --output output.md

Supports both Substack and Obsidian publishing formats.
"""

import argparse
import json
import os
import re
import sys
from datetime import datetime
from pathlib import Path


def extract_title_from_content(content):
    """Extract title from markdown content."""
    lines = content.split('\n')
    
    # Look for # heading first
    for line in lines:
        line = line.strip()
        if line.startswith('# '):
            return line[2:].strip()
    
    # If no # heading, use first non-empty line
    for line in lines:
        line = line.strip()
        if line and not line.startswith('```') and not line.startswith('---'):
            return line
    
    return "Untitled Blog Post"


def extract_excerpt(content, max_length=150):
    """Extract an excerpt from the content."""
    # Remove markdown formatting
    clean_content = re.sub(r'[*_#`]', '', content)
    clean_content = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', clean_content)  # Remove links but keep text
    
    # Get first paragraph after title
    lines = clean_content.split('\n')
    in_content = False
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
        
        # Skip title lines
        if not in_content and not line.startswith('---') and not line.lower().startswith('summary'):
            in_content = True
            # Skip if this looks like a title
            if len(line) < 50 and not '.' in line:
                continue
        
        if in_content and len(line) > 20:
            # Truncate if too long
            if len(line) > max_length:
                return line[:max_length-3] + "..."
            return line
    
    return "A comprehensive analysis of emerging trends and developments in the field."


def generate_frontmatter(content, target_format, custom_metadata=None):
    """Generate YAML frontmatter based on target platform."""
    title = extract_title_from_content(content)
    excerpt = extract_excerpt(content)
    
    # Base frontmatter
    frontmatter = {
        'title': title,
        'date': datetime.now().strftime('%Y-%m-%d'),
        'excerpt': excerpt
    }
    
    # Target-specific additions
    if target_format == 'substack':
        frontmatter.update({
            'type': 'newsletter',
            'layout': 'post'
        })
    elif target_format == 'obsidian':
        frontmatter.update({
            'tags': ['blog', 'research'],
            'category': 'research',
            'created': datetime.now().isoformat(),
            'modified': datetime.now().isoformat()
        })
    
    # Add custom metadata if provided
    if custom_metadata:
        frontmatter.update(custom_metadata)
    
    # Convert to YAML format
    yaml_lines = ['---']
    for key, value in frontmatter.items():
        if isinstance(value, list):
            yaml_lines.append(f"{key}:")
            for item in value:
                yaml_lines.append(f"  - {item}")
        else:
            yaml_lines.append(f"{key}: {value}")
    yaml_lines.append('---')
    
    return '\n'.join(yaml_lines)


def clean_content(content, target_format):
    """Clean and format content for publishing."""
    lines = content.split('\n')
    cleaned_lines = []
    skip_next_line = False
    
    for i, line in enumerate(lines):
        # Skip internal metadata
        if should_skip_line(line, skip_next_line):
            skip_next_line = False
            continue
        
        # Check if next line should be skipped
        if should_skip_next_line(line):
            skip_next_line = True
            continue
        
        # Clean up the current line
        cleaned_line = clean_line(line, target_format)
        if cleaned_line is not None:
            cleaned_lines.append(cleaned_line)
    
    # Clean up formatting
    cleaned_content = '\n'.join(cleaned_lines)
    
    # Final cleanup
    cleaned_content = final_cleanup(cleaned_content, target_format)
    
    return cleaned_content


def should_skip_line(line, skip_next_line):
    """Check if line should be skipped."""
    line = line.strip()
    
    # Skip if flagged by previous line
    if skip_next_line:
        return True
    
    # Skip internal metadata patterns
    skip_patterns = [
        'Generated by',
        'Agent:',
        'Domain:',
        'Source:',
        'Sources:',
        'Task:',
        'Version:',
        '---END OF OUTPUT---',
        '### Sources',
        '### Source URLs',
        '## Metadata',
        '**URL:**',
        '**Date:**',
        '**Agent:**'
    ]
    
    for pattern in skip_patterns:
        if pattern in line:
            return True
    
    return False


def should_skip_next_line(line):
    """Check if the next line should be skipped."""
    line = line.strip()
    
    # If this line indicates the next line is metadata
    next_line_skip_patterns = [
        'Sources:',
        'URL:',
        'Date:',
        'Agent:',
        'Generated by:'
    ]
    
    for pattern in next_line_skip_patterns:
        if line.endswith(pattern):
            return True
    
    return False


def clean_line(line, target_format):
    """Clean individual line based on target format."""
    line = line.rstrip()  # Preserve leading spaces
    
    # Skip empty lines at the start (after frontmatter will be added)
    if not line.strip():
        return line
    
    # Remove internal reference patterns
    line = re.sub(r'\[([^\]]+)\]\(\#internal-[^\)]+\)', r'\1', line)  # Internal links
    line = re.sub(r'\[Source:([^\]]+)\]\([^)]+\)', r'Source: \1', line)  # Source links
    
    # Platform-specific cleanup
    if target_format == 'substack':
        # Substack prefers simpler formatting
        line = line.replace('### ', '## ')  # Promote subheadings
        line = line.replace('#### ', '## ')  # Promote deeper headings
        
    elif target_format == 'obsidian':
        # Obsidian handles wikilinks well
        # Convert regular links to wikilinks for internal content
        line = re.sub(r'\[([^\]]+)\]\(https?://[^\)]+\)', r'[\1](\1)', line)
    
    return line


def final_cleanup(content, target_format):
    """Final cleanup of the entire content."""
    # Remove excessive blank lines
    content = re.sub(r'\n{3,}', '\n\n', content)
    
    # Fix broken markdown lists
    content = re.sub(r'^\s*-\s*$', '', content, flags=re.MULTILINE)
    
    # Ensure proper spacing around headings
    content = re.sub(r'\n(#{1,6})', r'\n\1', content)
    content = re.sub(r'(#{1,6}[^\n]+)\n([^\n#])', r'\1\n\n\2', content)
    
    # Platform-specific final touches
    if target_format == 'substack':
        # Add a call-to-action at the end if not present
        if not any(keyword in content.lower() for keyword in ['subscribe', 'follow', 'share']):
            content += '\n\n---\n\n*Enjoy this analysis? Consider subscribing for more insights on emerging technologies and industry trends.*'
    
    elif target_format == 'obsidian':
        # Add tags at the end if not present
        if not re.search(r'#\w+', content):
            content += '\n\n#blog #research #analysis'
    
    return content.strip()


def process_file(input_file, target_format, custom_metadata=None, output_file=None):
    """Process input file and generate formatted output."""
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except IOError as e:
        print(f"Error reading input file: {e}", file=sys.stderr)
        return False
    
    # Generate frontmatter
    frontmatter = generate_frontmatter(content, target_format, custom_metadata)
    
    # Clean content
    cleaned_content = clean_content(content, target_format)
    
    # Combine
    formatted_content = frontmatter + '\n\n' + cleaned_content
    
    # Output
    if output_file:
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(formatted_content)
            print(f"âœ… Formatted content saved to: {output_file}")
            return True
        except IOError as e:
            print(f"Error writing output file: {e}", file=sys.stderr)
            return False
    else:
        print(formatted_content)
        return True


def parse_custom_metadata(metadata_string):
    """Parse custom metadata from string format."""
    if not metadata_string:
        return None
    
    try:
        # Parse JSON format
        return json.loads(metadata_string)
    except json.JSONDecodeError:
        # Parse key=value format
        metadata = {}
        for pair in metadata_string.split(','):
            if '=' in pair:
                key, value = pair.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Try to detect type
                if value.lower() in ['true', 'false']:
                    value = value.lower() == 'true'
                elif value.startswith('[') and value.endswith(']'):
                    # Parse list format
                    value = [item.strip() for item in value[1:-1].split(',')]
                
                metadata[key] = value
        return metadata


def main():
    parser = argparse.ArgumentParser(
        description='Format blog drafts for publishing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    blog-publisher --target substack input.md > output.md
    blog-publisher --target obsidian input.md > output.md
    blog-publisher --input input.md --target substack --output output.md
    blog-publisher input.md substack --title "My Custom Title" --tags "AI,ML,Research"
        """
    )
    
    parser.add_argument('input_file', nargs='?', help='Input markdown file')
    parser.add_argument('target_format', nargs='?', choices=['substack', 'obsidian'], 
                       help='Target platform format')
    
    parser.add_argument('--input', dest='input_alt', help='Input file (alternative)')
    parser.add_argument('--target', choices=['substack', 'obsidian'], 
                       help='Target platform (alternative)')
    parser.add_argument('--output', help='Output file (default: stdout)')
    parser.add_argument('--metadata', help='Custom metadata (JSON or key=value format)')
    
    # Metadata shortcuts
    parser.add_argument('--title', help='Custom title')
    parser.add_argument('--tags', help='Comma-separated tags')
    parser.add_argument('--category', help='Post category')
    parser.add_argument('--author', help='Author name')
    
    args = parser.parse_args()
    
    # Resolve arguments
    input_file = args.input_file or args.input_alt
    target_format = args.target_format or args.target
    
    if not input_file or not target_format:
        parser.print_help()
        sys.exit(1)
    
    if not os.path.exists(input_file):
        print(f"Error: Input file {input_file} does not exist", file=sys.stderr)
        sys.exit(1)
    
    # Build custom metadata
    custom_metadata = parse_custom_metadata(args.metadata) or {}
    
    # Add shortcut metadata
    if args.title:
        custom_metadata['title'] = args.title
    if args.tags:
        custom_metadata['tags'] = [tag.strip() for tag in args.tags.split(',')]
    if args.category:
        custom_metadata['category'] = args.category
    if args.author:
        custom_metadata['author'] = args.author
    
    # Process file
    success = process_file(input_file, target_format, custom_metadata, args.output)
    
    if not success:
        sys.exit(1)


if __name__ == '__main__':
    main()